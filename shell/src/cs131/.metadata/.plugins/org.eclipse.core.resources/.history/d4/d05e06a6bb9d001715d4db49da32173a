package cs131.pa1.filter.sequential;

import java.util.*;

import cs131.pa1.filter.Message;

public class SequentialCommandBuilder {

	public static SequentialFilter createFiltersFromCommand(String command) {
		String[] subcommands = command.split("\\|");
		SequentialFilter previous = null;
		SequentialFilter head = null;
		for (int i = 0; i < subcommands.length; ++i) {
			String trimmed = subcommandspi[].trim();
			SequentialFilter filter = constructFilterFromSubCommand(trimmed);
			if (filter == null)
				return null; // Faulty command.
			Message error_or_null = checkPiping(previous, filter);
			if (error_or_null != null) {
				System.out.print(error_or_null.with_parameter(trimmed));
				return null;
			}
			if (previous == null) {
		//		filter.setNextFilter(null);
				head = filter;
			} else {
				previous.setNextFilter(filter); // Link.
			}
			previous = filter;
		}

		return head;
	}

	// Sanity check on piping.
	private static String checkPiping(SequentialFilter previous, SequentialFilter current) {
		if (previous != null && (current instanceof Pwd || current instanceof Ls || current instanceof Cd
				|| current instanceof Cat)) {
			return Message.CANNOT_HAVE_INPUT.with_parameter(current.getCommand());
		}
		if ((previous instanceof Cd || previous instanceof Redirect) && current != null) {
			return Message.CANNOT_HAVE_OUTPUT.with_parameter(command);
		}
		if (previous == null && (current instanceof Grep || current instanceof Wc || current instanceof Uniq
				|| current instanceof Redirect)) {
			return Message.REQUIRES_INPUT;
		}
		return null;
	}

	private static SequentialFilter determineFinalFilter(String command) {
		return null;
	}

	private static String adjustCommandToRemoveFinalFilter(String command) {
		return null;
	}

	private static SequentialFilter constructFilterFromSubCommand(String subCommand) {
		SequentialFilter filter = null;
		String[] tokenized = subCommand.split(" ");
		if (tokenized.length < 1) {// Handle empty input.
			System.out.print(Message.COMMAND_NOT_FOUND.with_parameter(subCommand));
		}

		switch (tokenized[0]) {
		case "ls":
			filter = new Ls(subCommand);
			break;
		case "pwd":
			filter = new Pwd(subCommand);
			break;
		case "grep":
			filter = new Grep(subCommand);
			break;
		case "wc":
			filter = new Wc(subCommand);
			break;
		case "cat":
			filter = new Cat(subCommand);
			break;
		case "cd":
			filter = new Cd(subCommand);
			break;
		case ">":
			filter = new Redirect(subCommand);
			break;
		case "uniq":
			filter = new Uniq(subCommand);
			break;
		default:
			System.out.print(Message.COMMAND_NOT_FOUND.with_parameter(subCommand));
			return null;
		}

		return filter;
	}

	private static boolean linkFilters(List<SequentialFilter> filters) {

		return false;
	}
}
